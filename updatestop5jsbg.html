<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Premium Interactive Backgrounds — Showcase</title>
<style>
  :root { --fg: #ffffff; --muted: rgba(255,255,255,0.85); }
  html,body { height:100%; margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:#0b0b0f; color:var(--fg); }
  /* fullpage sections */
  .wrap { scroll-behavior: smooth; }
  section {
    height:100vh;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }
  .card {
    position:relative;
    z-index:5;
    max-width:1000px;
    text-align:center;
    padding:24px;
    background:linear-gradient(180deg, rgba(0,0,0,0.24), rgba(0,0,0,0.12));
    border-radius:12px;
    box-shadow:0 8px 30px rgba(0,0,0,0.6);
    backdrop-filter: blur(6px) saturate(120%);
  }
  h1 { margin:0 0 8px; font-size: clamp(20px, 4vw, 36px); }
  p { margin:0; color:var(--muted); font-size: clamp(14px,2vw,18px); }

  /* containers for backgrounds (fill) */
  .bgFill { position:absolute; inset:0; width:100%; height:100%; z-index:0; pointer-events:none; }

  /* small nav dots */
  .nav {
    position:fixed; right:18px; top:50%; transform:translateY(-50%); z-index:10;
    display:flex; flex-direction:column; gap:12px;
  }
  .nav a { width:12px; height:12px; border-radius:50%; display:block; background:rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.05); box-shadow:0 2px 6px rgba(0,0,0,0.6); }
  .nav a.active { background:#fff; box-shadow:0 6px 18px rgba(0,0,0,0.6); }

  /* small caption */
  .caption { position: absolute; left:18px; bottom:18px; z-index:6; color:rgba(255,255,255,0.8); font-size:13px; }
  /* responsive tweaks */
  @media (max-width:700px){
    .card{ margin:24px; width:calc(100% - 48px); }
    .nav{ display:none; }
  }
</style>
</head>
<body>
  <nav class="nav" id="nav">
    <a href="#s1" id="n1" class="active" title="Shader Gradient"></a>
    <a href="#s2" id="n2" title="Tilt Parallax"></a>
    <a href="#s3" id="n3" title="SVG Gooey"></a>
    <a href="#s4" id="n4" title="Noise & Grain"></a>
    <a href="#s5" id="n5" title="Fluid Particles"></a>
  </nav>

  <div class="wrap">
    <!-- 1: Shader-based animated gradient -->
    <section id="s1">
      <canvas id="shaderCanvas" class="bgFill"></canvas>
      <div class="card">
        <h1>Shader-based Animated Gradient</h1>
        <p>Smooth, organic color flows driven by a fragment shader (WebGL). Subtle mouse interaction included.</p>
      </div>
      <div class="caption">Section 1 / Shader Gradient</div>
    </section>

    <!-- 2: Mouse-Tilt Parallax -->
    <section id="s2">
      <div id="parallax" class="bgFill" aria-hidden="true">
        <div class="layer" data-depth="0.08" style="position:absolute;inset:-10%  -20%  -10% -20%; background:radial-gradient(circle at 20% 30%, rgba(255,160,120,0.14), transparent 12%), radial-gradient(circle at 80% 70%, rgba(0,150,255,0.12), transparent 10%); filter:blur(40px);"></div>
        <div class="layer" data-depth="0.18" style="position:absolute;inset:10% 5% 30% 20%; background:linear-gradient(120deg, rgba(255,255,255,0.03), transparent); transform:scale(1.1);"></div>
        <div class="layer" data-depth="0.36" style="position:absolute; width:1200px; height:1200px; left:50%; top:50%; transform:translate(-50%,-50%); background: conic-gradient(from 200deg at 50% 50%, rgba(255,80,90,0.06), rgba(80,180,255,0.06)); filter:blur(80px);"></div>
      </div>
      <div class="card">
        <h1>Mouse-Tilt & Gyro Parallax</h1>
        <p>Multi-layer parallax that subtly reacts to mouse or device tilt — gives depth without heavy distraction.</p>
      </div>
      <div class="caption">Section 2 / Parallax</div>
    </section>

    <!-- 3: SVG Gooey Morph -->
    <section id="s3">
      <svg id="gooeySvg" class="bgFill" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice" style="width:100%;height:100%;">
        <defs>
          <filter id="goo"><feGaussianBlur in="SourceGraphic" stdDeviation="18" result="blur"/><feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 20 -10" result="goo"/><feBlend in="SourceGraphic" in2="goo"/></filter>
        </defs>
        <g filter="url(#goo)" id="blobs"></g>
      </svg>
      <div class="card">
        <h1>SVG Gooey Morphing Shapes</h1>
        <p>Blobby shapes that merge and separate — a ‘metaball’ gooey effect done with SVG + blur filter. Interactive on hover/click.</p>
      </div>
      <div class="caption">Section 3 / SVG Gooey</div>
    </section>

    <!-- 4: Noise + Grain Overlay -->
    <section id="s4" style="background: linear-gradient(180deg,#061021 0%, #0b1220 100%);">
      <canvas id="grainCanvas" class="bgFill"></canvas>
      <div class="card">
        <h1>Animated Noise & Grain Overlay</h1>
        <p>Subtle animated grain / film-noise overlay that adds tactile, cinematic texture to any background.</p>
      </div>
      <div class="caption">Section 4 / Noise & Grain</div>
    </section>

    <!-- 5: Fluid-ish Particle Flow -->
    <section id="s5">
      <canvas id="fluidCanvas" class="bgFill"></canvas>
      <div class="card">
        <h1>3D-like Fluid Particle Flow</h1>
        <p>Interactive particle vortices with smoothing/blur to create a fluid impression — responds to your mouse/touch.</p>
      </div>
      <div class="caption">Section 5 / Fluid Particles</div>
    </section>
  </div>

<script>
/* Navigation active state on scroll */
const sections = [...document.querySelectorAll('section')];
const nav = document.getElementById('nav');
const navLinks = [ 'n1','n2','n3','n4','n5' ].map(id => document.getElementById(id));
const io = new IntersectionObserver(entries => {
  entries.forEach(e => {
    if(e.isIntersecting){
      const idx = sections.indexOf(e.target);
      navLinks.forEach(n => n.classList.remove('active'));
      navLinks[idx].classList.add('active');
    }
  });
},{threshold: 0.6});
sections.forEach(s => io.observe(s));

/* -------------------------
   1) Shader-based animated gradient (WebGL)
   ------------------------- */
(function(){
  const canvas = document.getElementById('shaderCanvas');
  const gl = canvas.getContext('webgl');
  if(!gl){ /* graceful fallback: solid bg */ canvas.style.background = 'linear-gradient(120deg,#0f1724,#061226)'; return; }
  function resize(){
    const dpr = Math.min(window.devicePixelRatio||1, 2);
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize', resize); resize();

  // simple passthrough vertex shader
  const vsrc = `
    attribute vec2 aPos;
    varying vec2 vUv;
    void main(){ vUv = aPos*0.5+0.5; gl_Position = vec4(aPos,0.0,1.0); }
  `;
  // fragment: organic gradient using sin + rotating color palette, mouse influence
  const fsrc = `
    precision highp float;
    varying vec2 vUv;
    uniform float uTime;
    uniform vec2 uRes;
    uniform vec2 uMouse;
    // simple pseudo-random
    float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123); }
    // fbm-like noise
    float noise(vec2 p){
      float z = 0.0; float amp = 0.5;
      for(int i=0;i<5;i++){
        z += amp * hash(floor(p));
        p *= 2.0;
        amp *= 0.5;
      }
      return z;
    }
    void main(){
      vec2 uv = vUv;
      vec2 st = (gl_FragCoord.xy / uRes.xy);
      vec2 m = uMouse / uRes;
      float t = uTime * 0.2;
      // flowing bands
      float n = 0.0;
      n += sin((uv.x*4.0 + t) + noise(uv*10.0) * 2.0) * 0.5;
      n += cos((uv.y*3.0 - t*1.2) + noise(uv*8. + vec2(5.))*1.0) * 0.25;
      // mouse ripple influence
      vec2 d = uv - m;
      float dm = exp(-dot(d,d)*35.0);
      n += dm * 0.8;
      // color palette mix
      vec3 a = vec3(0.02,0.12,0.20);
      vec3 b = vec3(0.02,0.28,0.46);
      vec3 c = vec3(0.98,0.55,0.24);
      vec3 col = mix(a,b, smoothstep(-0.5,0.8, n));
      col = mix(col, c, pow(smoothstep(0.3,0.9, n), 1.6));
      // final desaturation
      float lum = dot(col, vec3(0.299,0.587,0.114));
      col = mix(col, vec3(lum), 0.06);
      gl_FragColor = vec4(col,1.0);
    }
  `;
  // compile helpers
  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(sh)); return null;
    }
    return sh;
  }
  const vs = compile(gl.VERTEX_SHADER, vsrc);
  const fs = compile(gl.FRAGMENT_SHADER, fsrc);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(prog)); return; }
  gl.useProgram(prog);
  // quad
  const pos = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW);
  const aPos = gl.getAttribLocation(prog, 'aPos');
  gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

  // uniforms
  const uTime = gl.getUniformLocation(prog, 'uTime');
  const uRes  = gl.getUniformLocation(prog, 'uRes');
  const uMouse= gl.getUniformLocation(prog, 'uMouse');
  let start = performance.now();
  let mouse = {x: innerWidth*0.5, y: innerHeight*0.5};
  window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = innerHeight - e.clientY; });
  window.addEventListener('touchmove', e => { if(e.touches[0]){ mouse.x = e.touches[0].clientX; mouse.y = innerHeight - e.touches[0].clientY; }},{passive:true});
  function frame(){
    resize(); // safe to call
    gl.uniform1f(uTime, (performance.now()-start)/1000);
    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.uniform2f(uMouse, mouse.x * (window.devicePixelRatio||1), mouse.y * (window.devicePixelRatio||1));
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(frame);
  }
  frame();
})();

/* -------------------------
   2) Mouse-Tilt / Gyro Parallax
   ------------------------- */
(function(){
  const container = document.getElementById('parallax');
  const layers = [...container.querySelectorAll('.layer')];
  let cx = innerWidth/2, cy = innerHeight/2;
  function moveLayers(x,y){
    const dx = (x - cx) / cx; // -1..1
    const dy = (y - cy) / cy;
    layers.forEach(el => {
      const d = parseFloat(el.dataset.depth) || 0.1;
      const tx = dx * d * 30;
      const ty = dy * d * 30;
      el.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${1 + d*0.03}) rotate(${d*3}deg)`;
    });
  }
  window.addEventListener('mousemove', e => moveLayers(e.clientX, e.clientY));
  // device orientation for mobile
  window.addEventListener('deviceorientation', e => {
    const gamma = e.gamma || 0; // left/right [-90,90]
    const beta = e.beta || 0; // front/back [-180,180]
    const x = cx + (gamma/90) * cx;
    const y = cy + (beta/90) * cy;
    moveLayers(x,y);
  }, true);
  // gentle idle animation
  let t0 = 0;
  (function idleAnim(ts){
    t0 += 0.005;
    const x = cx + Math.sin(t0)*cx*0.02;
    const y = cy + Math.cos(t0*0.7)*cy*0.02;
    moveLayers(x,y);
    requestAnimationFrame(idleAnim);
  })(0);
})();

/* -------------------------
   3) SVG Gooey Morphing Shapes
   ------------------------- */
(function(){
  const svg = document.getElementById('gooeySvg');
  const blobsG = document.getElementById('blobs');
  const w = 1200, h = 800;
  const N = 12;
  const blobs = [];
  for(let i=0;i<N;i++){
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('r', 40 + Math.random()*60);
    c.setAttribute('fill', `rgba(255,${120 + Math.floor(Math.random()*120)}, ${80 + Math.floor(Math.random()*140)}, ${0.95})`);
    blobsG.appendChild(c);
    blobs.push({el:c, x: Math.random()*w, y:Math.random()*h, vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6, r: parseFloat(c.getAttribute('r'))});
  }
  // keep svg viewBox synced with viewport aspect
  function resize(){
    const vbW = Math.max(innerWidth, 900);
    const vbH = Math.max(innerHeight, 600);
    svg.setAttribute('viewBox', `0 0 ${vbW} ${vbH}`);
  }
  window.addEventListener('resize', resize); resize();

  // mouse influence & click burst
  let mx = -9999, my = -9999;
  svg.addEventListener('mousemove', e => { const rc = svg.getBoundingClientRect(); mx = (e.clientX - rc.left) * (svg.viewBox.baseVal.width / rc.width); my = (e.clientY - rc.top) * (svg.viewBox.baseVal.height / rc.height); });
  svg.addEventListener('mouseleave', ()=>{ mx=-9999; my=-9999; });
  svg.addEventListener('click', e => {
    for(let b of blobs){ b.vx += (Math.random()-0.5)*6; b.vy += (Math.random()-0.5)*6; }
  });

  function step(){
    const vbW = svg.viewBox.baseVal.width, vbH = svg.viewBox.baseVal.height;
    for(let b of blobs){
      // attraction to center
      const cx = vbW*0.5, cy = vbH*0.5;
      const dx = cx - b.x, dy = cy - b.y;
      b.vx += dx * 0.0002;
      b.vy += dy * 0.0002;
      // mouse repulsion/attraction
      if(mx>-9000){
        const dxm = b.x - mx, dym = b.y - my;
        const d2 = dxm*dxm + dym*dym;
        if(d2 < 40000){
          const f = 4 / (1 + Math.sqrt(d2));
          b.vx += dxm * 0.001 * f;
          b.vy += dym * 0.001 * f;
        }
      }
      // update pos
      b.x += b.vx;
      b.y += b.vy;
      // friction
      b.vx *= 0.98; b.vy *= 0.98;
      // wrap edges softly
      if(b.x < -100) b.x = vbW + 100;
      if(b.x > vbW+100) b.x = -100;
      if(b.y < -100) b.y = vbH + 100;
      if(b.y > vbH+100) b.y = -100;
      b.el.setAttribute('cx', b.x);
      b.el.setAttribute('cy', b.y);
    }
    requestAnimationFrame(step);
  }
  step();
})();

/* -------------------------
   4) Noise + Grain Overlay
   ------------------------- */
(function(){
  const c = document.getElementById('grainCanvas');
  const ctx = c.getContext('2d');
  function resize(){ c.width = innerWidth; c.height = innerHeight; c.style.width = innerWidth+'px'; c.style.height = innerHeight+'px'; }
  window.addEventListener('resize', resize); resize();
  // pre-generate a small noise tile then tile-draw with random globalAlpha changes for subtle animation
  const tileSize = 256;
  const tile = document.createElement('canvas');
  tile.width = tileSize; tile.height = tileSize;
  const tctx = tile.getContext('2d');
  function genTile(){
    const id = tctx.createImageData(tileSize, tileSize);
    for(let i=0;i<id.data.length;i+=4){
      const val = Math.floor(Math.random()*255);
      id.data[i]=id.data[i+1]=id.data[i+2]=val;
      id.data[i+3]=20; // low alpha for subtlety
    }
    tctx.putImageData(id,0,0);
  }
  genTile();
  let last = 0;
  function draw(ts){
    // slight regeneration occasionally to avoid repetition
    if(ts - last > 120) { genTile(); last = ts; }
    ctx.clearRect(0,0,c.width,c.height);
    // tile pattern
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.08 + Math.random()*0.05;
    for(let x=0;x<c.width;x+=tileSize) for(let y=0;y<c.height;y+=tileSize) ctx.drawImage(tile, x, y);
    // subtle vignette
    const g = ctx.createRadialGradient(c.width/2, c.height/2, Math.min(c.width,c.height)*0.1, c.width/2, c.height/2, Math.max(c.width,c.height)*0.75);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,0.22)');
    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = g;
    ctx.fillRect(0,0,c.width,c.height);
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();

/* -------------------------
   5) Fluid-ish Particle Flow (Canvas)
   ------------------------- */
(function(){
  const c = document.getElementById('fluidCanvas');
  const ctx = c.getContext('2d');
  let W = innerWidth, H = innerHeight;
  function resize(){ W = c.width = innerWidth; H = c.height = innerHeight; c.style.width = W+'px'; c.style.height = H+'px'; }
  window.addEventListener('resize', resize); resize();

  // particles with simple velocity field and smoothing draw to mimic fluid
  const P = 260; // particle count
  const particles = [];
  for(let i=0;i<P;i++){
    particles.push({
      x: Math.random()*W,
      y: Math.random()*H,
      vx: (Math.random()-0.5)*0.6,
      vy: (Math.random()-0.5)*0.6,
      s: 1 + Math.random()*2,
      life: 100 + Math.random()*200
    });
  }
  let mouseX = -9999, mouseY=-9999, mouseDown=false;
  function mouseMove(e){ mouseX = e.clientX; mouseY = e.clientY; }
  function touchMove(e){ if(e.touches[0]){ mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; } }
  window.addEventListener('mousemove', mouseMove);
  window.addEventListener('touchmove', touchMove, {passive:true});
  window.addEventListener('mousedown', ()=>mouseDown=true); window.addEventListener('mouseup', ()=>mouseDown=false);

  function update(){
    // draw on an offscreen blurred canvas for glow effect
    ctx.clearRect(0,0,W,H);
    // additive blending for glow
    ctx.globalCompositeOperation = 'lighter';
    for(let p of particles){
      // field: simple curl/noise-like field using sin/cos based on position and time
      const t = performance.now()*0.00035;
      const angle = Math.sin((p.y*0.008) + t*1.2) * 2.0 + Math.cos((p.x*0.009) - t*0.8);
      p.vx += Math.cos(angle) * 0.12 * p.s * 0.02;
      p.vy += Math.sin(angle) * 0.12 * p.s * 0.02;
      // mouse influence
      if(mouseX>-9000){
        const dx = p.x - mouseX, dy = p.y - mouseY;
        const d2 = dx*dx + dy*dy;
        if(d2 < 20000){
          const f = (20000 - d2) / 20000;
          p.vx += dx * 0.0007 * (mouseDown? 3 : 1) * f;
          p.vy += dy * 0.0007 * (mouseDown? 3 : 1) * f;
        }
      }
      // motion
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.94; p.vy *= 0.94;
      p.life--;
      if(p.life<=0 || p.x < -50 || p.x > W+50 || p.y < -50 || p.y > H+50){
        // reset
        p.x = Math.random()*W; p.y = Math.random()*H; p.vx = (Math.random()-0.5)*0.6; p.vy=(Math.random()-0.5)*0.6;
        p.life = 80+Math.random()*300;
        p.s = 1 + Math.random()*2;
      }

      // render particle as radial gradient
      const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.s*28);
      g.addColorStop(0, 'rgba(120,200,255,0.9)');
      g.addColorStop(0.25, 'rgba(80,160,255,0.35)');
      g.addColorStop(0.6, 'rgba(20,40,80,0.06)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.s*28, 0, Math.PI*2);
      ctx.fill();
    }
    // subtle screen blend overlay to darken edges
    ctx.globalCompositeOperation = 'destination-over';
    const dark = ctx.createLinearGradient(0,0,0,H);
    dark.addColorStop(0, 'rgba(0,8,20,0.0)');
    dark.addColorStop(1, 'rgba(0,0,0,0.18)');
    ctx.fillStyle = dark;
    ctx.fillRect(0,0,W,H);
    requestAnimationFrame(update);
  }
  update();
})();
</script>
</body>
</html>
